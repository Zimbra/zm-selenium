testng.xml:

<test> ------------->Test1(just a set of testclasses)
<groups>
	<include> always </include>
	<include> smoke </include>
	<class1> ------------------>say contains testMethod1, testMethod2
	<class2>------------------> say contains testMethod3, testMethod4
 </test>
 <test>------------->Test2(just a set of testclasses)
	<class3>
<test>
</test>

1.(SelNGBase.java) isExecutionARetry and needReset is set to false 
2.(CommonTest.java)BeforeSuite method is run,
 -Start selenium server
 -Create selenium-session with the required browser
 -Setup Zimbra testbed: create testdomain.com, create couple of users like ccuser@testdomain.com and bccuser@testdomain.com

3. Count the <test> tags in testng.xml
for(i==0; i < testTagCount; i++) {
	4. Read the  test-tag[i](say first test-tag) from testng.xml file. 
	 - Read all the classes/packages defined in that <test> tag
	 ..In our example, we have 2 classes (Class1 and Class2) under first test-tag
	 - Read the groups to be included and excluded in each <test> tag
	for(j ==0; j < classCount; j++) {
		5. Start with the class[j](say class1) in the first-<test>tag 
		6. Run BeforeClass(usually loginToZimbra method and *** sets isExecutionARetry to false(so spillover from different class affects this class))
		..In our example, testng starts running class1 in Test1
		6.1 Check all the methods in class1
		..it will get testMethod1 and testMethod2
		6.2 for(k==0; k< testMethodsCount; k++) {
			7. Get testMethod[k](say testMethod1)
			 8 Check if there is any method with @beforeMethod, if so, run that
			..usually beforeMethod will have logic like: *re-login* to zimbra if earlier-test has failed
			8.1 if(Hasdataprovider) {
				 count the # of data-sets:
				 for(each different data) {
					9. run test(like: testMethod1) with different data
					9.1 TestMethod1 checks if isExecutionARetry is false,
					 ...if (isExecutionARetry is false) {
						this is the first time test is being called and things are fine
						
					} else if(isExecutionARetry is true) {
						call retry-logicFunction
						 -- this usually relogin and also has navigateTo functions that will bring back the
						 state of the application so that test-can be re-run as normal
						 -*****Resets isExecutionARetry to false so that the retry-wont go to infinite-loop
					}
					
					9.2 go ahead with the test-steps
					9.2.1 If (there is an exception while running actual test) {
						Check if retryAnalyzer = RetryFailedTests.class is present.
						if(retryAnalyzer = RetryFailedTests.class is present) {
							..retryFailedTests.java automatically takes over
							if(we have already retried > 2 times) {
								..Most likely its a real failure. 
								- throw exception
								- return control to 6.2 for the nextTestMethod
							} else if(this is 1st or 2nd time we are retrying) {
								-  ***sets isExecutionARetry to true
								-  ***sets needReset to true 
								- return control to Step9(now that the isExecutionARety is true, relogin etc will happen before tests are run)
							}
					    }
					9.2.2 If things go fine: ***set needReset to false(obsolete if you have retryFailedTests.java handler)
				}
			8.2 } else if(no dataprovider) {
				9. simply run the testMethod(like: TestMethod1) once. 
				...Assumes that the data is not required or data is hard-coded within the testMethod
					9.1 TestMethod1 checks if isExecutionARetry is false,
					 ...if (isExecutionARetry is false) {
						this is the first time test is being called and things are fine
						
					} else if(isExecutionARetry is true) {
						call retry-logicFunction
						 -- this usually relogin and also has navigateTo functions that will bring back the
						 state of the application so that test-can be re-run as normal
						 -Resets isExecutionARetry to false so that the retry-wont go to infinite-loop
					}
					
					9.2 go ahead with the test-steps
					9.2.1 If (there is an exception while running actual test) {
						Check if retryAnalyzer = RetryFailedTests.class is present.
						if(retryAnalyzer = RetryFailedTests.class is present) {
							..retryFailedTests.java automatically takes over
							if(we have already retried > 2 times) {
								..Most likely its a real failure. 
								- throw exception
								- return control to 6.2 for the nextTestMethod
							} else if(this is 1st or 2nd time we are retrying) {
								-  ***sets isExecutionARetry to true
								-  ***sets needReset to true 
								- return control to Step9(now that the isExecutionARety is true, relogin etc will happen before tests are run)
							}
					    }
					9.2.2 If things go fine: ***set needReset to false(obsolete if you have retryFailedTests.java handler)
			}

		}

Some more notes:
- If your test-class uses dependsOnMethod, then that entire class must be placed in a separate <test> tag
- If your test-class uses dependsOnMethod, then retry-logic must call all the depends-on methods with hard-coded datas
ex: testMethod3 depends ont testMethod2(String somedata2) depends on testMethod1(String someData1)
Then testMethod3(sometestData3){
	if(isExecutionARetry) {
		testMethod3_retry()
	}
	Click on somebtn1
	verify something
}
your retry method would look something like:
 testMethod3_retry() {
	isExecutionARetry = false // must be present otherwise your test will go to infinite loop
	login()
	call testMethod1("this is data1"); //notice the real-data being passed
	call testMethod2("this is data2");
}
	