package projects.zcs.tests.compose;

import java.lang.reflect.Method;

import org.testng.Assert;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import framework.util.RetryFailedTests;

import projects.zcs.tests.CommonTest;
import projects.zcs.ui.ComposeView;
import projects.zcs.ui.MailApp;

// THERE ARE 4 SECTIONS
//1. DATAPROVIDERS <Optional> If your tests uses data-driven testing, then use this to pass data
//2. SETUP: BeforeClass and BeforeMethod methods -- used for open zimbra and login with specific user. also checks we need to relogin based on previous test's result(success/failure)
//3. TEST/TEST-METHODS: Actual tests
//4. RETRY-METHODS: If a test fails, then these methods take care of bringing the AUT to proper state(like relogin, re-navigate etc) so that the test can be re-run


@SuppressWarnings("static-access")
public class MyTest extends CommonTest {
//==========================================================================================
//1. DATAPROVIDERS <Optional> If your tests uses data-driven testing, then use this to pass data
//==========================================================================================
    @DataProvider(name = "myDataProvider")
    public Object[][] createData(Method method) {
		    return new Object[][] {	
						{"data1"}, 
						{"data2"},
						{"data3"}
					  };
    }
//==========================================================================================
//2. SETUP: BeforeClass and BeforeMethod methods -- used for open zimbra and login with specific user. 
 - also checks we need to relogin based on previous test's result(success/failure)
//==========================================================================================
   //This is the first-method to run before doing anything *within this* class	and is run only-once.
    @BeforeClass(groups = { "always" })
    public void zLogin() throws Exception {		
	zLoginIfRequired();
	isExecutionARetry = false;//required to have a clean start
    }
    // This method is run before *every-single* testMethods within this class.
    // if there are two testMethods(testMethod1 and testMethod2) the callis done like: zResetIfRequired()-> testMethod1() ->zResetIfRequired-> testMethod2()
    @BeforeMethod(groups = { "always" })
    public void zResetIfRequired() throws Exception {
	if (needReset && !isExecutionARetry) {
	    zLogin();
	}
	needReset = true;//start with needReset as true, if the realTestMethod is run successfully, it will set this to false or else we would know that there was some issue and
	since this method is run before every testMethod, we can reset it(like relogin etc)
    }
//==========================================================================================
//3. TEST/TEST-METHODS: Actual test
//==========================================================================================
    @Test(dataProvider = "myDataProvider", groups = { "smoke", "full" }, retryAnalyzer = RetryFailedTests.class)
    public void myFirstTest(String someData) throws Exception {
    //This is a test since it has @Test on top of this
    // This uses myDataProvider to pass data, since there is 3 data in dataprovider, this will be run 3 times	
    //This belongs to both smoke and full groups. So unless both these groups are excluded(in testng.xml), this test will be run
    // This test also has retryAnalyzer = RetryFailedTests.class, this means if there is any exception, this test is rerun upto 2 times(current setting)
	if (isExecutionARetry)
	    handleRetry();// this method must take care of relogging-in, navigation etc to bring the state of the aut so that STEP1 can proceed
	STEP1: click on some button
	STEP2 verify something exists
	needReset = false;//if the method reaches this line, that means everything went fine(if there is an exception in STEP1 or STEP2, it wont even reach this line
    }


//uses dependsOnMethod
    @Test(dataProvider = "myDataProvider", dependsOnMethods = "myFirstTest", groups = {
	    "smoke", "full"}, retryAnalyzer = RetryFailedTests.class)
    public void mySecondTest(String someData) throws Exception {
    //This is a test since it has @Test on top of this
    // This uses myDataProvider to pass data, since there is 3 data in dataprovider, this will be run 3 times	
    //This belongs to both smoke and full groups. So unless both these groups are excluded, this test will be run
    // This test also has retryAnalyzer = RetryFailedTests.class, this means if there is any exception, this test is rerun upto 2 times(current setting)
    //Uses dependsOnMethods, so this is executed AFTER myFirstTest. This also means if we are retrying, the retry-logic(mysecondTest_retry) must also call
    //myFirstTest.
	if (isExecutionARetry) {
	// this method must take care of relogging-in, navigation etc to bring the state of the aut so that STEP1 can proceed
	Since we are using dependsOnMethods, This also means if we are retrying, the retry-logic(mysecondTest_retry) must also call myFirstTest.
	    mySecondTest_retry();
	}
	STEP1: click on some button
	STEP2 verify something exists
	needReset = false;//if the method reaches this line, that means everything went fine(if there is an exception in STEP1 or STEP2, it wont even reach this line
    }

//==========================================================================================
//4. RETRY-METHODS: If a test fails, then these methods take care of bringing the AUT to proper state(like relogin, re-navigate etc) so that the test can be re-run
//==========================================================================================
    // for those that needs just relogin
    private void handleRetry() throws Exception {
	isExecutionARetry = false;// reset this to false so the tests dont go to infinite loop
	zLogin();
    }

    private void mySecondMethod_retry() throws Exception {
    isExecutionARetry = false;// reset this to false so the tests dont go to infinite loop
	handleRetry();// relogin
	myFirstTest("some data");//Call myFirstTest since mySeconeTest depends on it. Note the data is hardcoded
    }